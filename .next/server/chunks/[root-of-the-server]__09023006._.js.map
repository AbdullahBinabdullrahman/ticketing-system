{"version":3,"sources":["turbopack:///[project]/projects/ticketing-platform/lib/db/connection.ts","turbopack:///[project]/projects/ticketing-platform/lib/utils/logger.ts","turbopack:///[project]/projects/ticketing-platform/lib/utils/errorHandler.ts","turbopack:///[project]/projects/ticketing-platform/lib/services/authService.ts"],"sourcesContent":["import \"dotenv/config\";\n\nimport { drizzle } from \"drizzle-orm/postgres-js\";\nimport postgres from \"postgres\";\n\nconst connectionString = process.env.DATABASE_URL;\n\nif (!connectionString) {\n  throw new Error(\"DATABASE_URL environment variable is not set\");\n}\n\n// Configure postgres client with connection pooling and timeout settings\nexport const client = postgres(connectionString, { \n  prepare: false, // Disable prefetch as it is not supported for \"Transaction\" pool mode\n  max: 10, // Maximum connections in pool\n  idle_timeout: 20, // Close idle connections after 20 seconds\n  connect_timeout: 30, // Connection timeout in seconds (increased from 10)\n  max_lifetime: 60 * 30, // Max lifetime of connection (30 minutes)\n  connection: {\n    application_name: 'ticketing-system'\n  },\n  onnotice: () => {}, // Suppress notices\n  debug: process.env.NODE_ENV === 'development' ? false : undefined, // Disable debug in production\n});\n\nexport const db = drizzle(client);\n\n// Handle process termination to cleanup connections\nif (typeof process !== 'undefined') {\n  process.on('SIGTERM', async () => {\n    console.log('SIGTERM received, closing database connections...');\n    await client.end({ timeout: 5 });\n  });\n\n  process.on('SIGINT', async () => {\n    console.log('SIGINT received, closing database connections...');\n    await client.end({ timeout: 5 });\n  });\n}\n","type LogLevel = \"debug\" | \"info\" | \"warn\" | \"error\";\n\ninterface LogEntry {\n  level: LogLevel;\n  message: string;\n  timestamp: string;\n  context?: Record<string, unknown>;\n  userId?: number;\n  requestId?: string;\n}\n\nclass Logger {\n  private isDevelopment = process.env.NODE_ENV === \"development\";\n  private logLevel: LogLevel = (process.env.LOG_LEVEL as LogLevel) || \"info\";\n\n  private shouldLog(level: LogLevel): boolean {\n    const levels: Record<LogLevel, number> = {\n      debug: 0,\n      info: 1,\n      warn: 2,\n      error: 3,\n    };\n    return levels[level] >= levels[this.logLevel];\n  }\n\n  private formatLog(entry: LogEntry): string {\n    const { level, message, timestamp, context, userId, requestId } = entry;\n\n    let logMessage = `[${timestamp}] [${level.toUpperCase()}]`;\n\n    if (userId) logMessage += ` [USER:${userId}]`;\n    if (requestId) logMessage += ` [REQ:${requestId}]`;\n\n    logMessage += ` ${message}`;\n\n    if (context && Object.keys(context).length > 0) {\n      logMessage += ` | Context: ${JSON.stringify(context)}`;\n    }\n\n    return logMessage;\n  }\n\n  private log(\n    level: LogLevel,\n    message: string,\n    context?: Record<string, unknown>,\n    userId?: number,\n    requestId?: string\n  ) {\n    if (!this.shouldLog(level)) return;\n\n    const entry: LogEntry = {\n      level,\n      message,\n      timestamp: new Date().toISOString(),\n      context,\n      userId,\n      requestId,\n    };\n\n    const formattedLog = this.formatLog(entry);\n\n    if (this.isDevelopment) {\n      // In development, use console with colors\n      const colors = {\n        debug: \"\\x1b[36m\", // Cyan\n        info: \"\\x1b[32m\", // Green\n        warn: \"\\x1b[33m\", // Yellow\n        error: \"\\x1b[31m\", // Red\n      };\n      const reset = \"\\x1b[0m\";\n      console.log(`${colors[level]}${formattedLog}${reset}`);\n    } else {\n      // In production, use structured logging\n      console.log(JSON.stringify(entry));\n    }\n  }\n\n  debug(\n    message: string,\n    context?: Record<string, unknown>,\n    userId?: number,\n    requestId?: string\n  ) {\n    this.log(\"debug\", message, context, userId, requestId);\n  }\n\n  info(\n    message: string,\n    context?: Record<string, unknown>,\n    userId?: number,\n    requestId?: string\n  ) {\n    this.log(\"info\", message, context, userId, requestId);\n  }\n\n  warn(\n    message: string,\n    context?: Record<string, unknown>,\n    userId?: number,\n    requestId?: string\n  ) {\n    this.log(\"warn\", message, context, userId, requestId);\n  }\n\n  error(\n    message: string,\n    context?: Record<string, unknown>,\n    userId?: number,\n    requestId?: string\n  ) {\n    this.log(\"error\", message, context, userId, requestId);\n  }\n\n  // Specialized logging methods\n  apiRequest(\n    method: string,\n    url: string,\n    body?: Record<string, unknown> | null,\n    userId?: number | undefined,\n    requestId?: string | undefined\n  ) {\n    this.info(\n      `API Request: ${method} ${url}`,\n      { method, url, ...body },\n      userId,\n      requestId\n    );\n  }\n\n  apiResponse(\n    method: string,\n    url: string,\n    statusCode: number,\n    duration: number,\n    userId?: number,\n    requestId?: string\n  ) {\n    this.info(\n      `API Response: ${method} ${url} - ${statusCode} (${duration}ms)`,\n      { method, url, statusCode, duration },\n      userId,\n      requestId\n    );\n  }\n\n  databaseQuery(\n    query: string,\n    duration: number,\n    userId?: number,\n    requestId?: string\n  ) {\n    this.debug(\n      `Database Query: ${query} (${duration}ms)`,\n      { query, duration },\n      userId,\n      requestId\n    );\n  }\n\n  authEvent(\n    event: string,\n    userId?: number,\n    details?: Record<string, unknown>,\n    requestId?: string\n  ) {\n    this.info(`Auth Event: ${event}`, { event, ...details }, userId, requestId);\n  }\n\n  businessEvent(\n    event: string,\n    entityType: string,\n    entityId: number,\n    userId?: number,\n    details?: Record<string, unknown>,\n    requestId?: string\n  ) {\n    this.info(\n      `Business Event: ${event}`,\n      { event, entityType, entityId, ...details },\n      userId,\n      requestId\n    );\n  }\n\n  errorEvent(\n    error: Error,\n    context?: Record<string, unknown>,\n    userId?: number,\n    requestId?: string\n  ) {\n    this.error(\n      `Error Event: ${error.message}`,\n      {\n        error: error.message,\n        stack: error.stack,\n        ...context,\n      },\n      userId,\n      requestId\n    );\n  }\n}\n\nexport const logger = new Logger();\nexport default logger;\n","import { NextApiResponse } from \"next\";\nimport { ZodError } from \"zod\";\n\nexport interface ApiError {\n  message: string;\n  code?: string;\n  statusCode: number;\n  details?: Record<string, unknown>;\n}\n\nexport class AppError extends Error {\n  public statusCode: number;\n  public code?: string;\n  public details?: Record<string, unknown>;\n\n  constructor(\n    message: string,\n    statusCode: number = 500,\n    code?: string,\n    details?: Record<string, unknown>\n  ) {\n    super(message);\n    this.statusCode = statusCode;\n    this.code = code;\n    this.details = details;\n    this.name = \"AppError\";\n  }\n}\n\nexport function handleApiError(error: unknown): ApiError {\n  if (error instanceof AppError) {\n    return {\n      message: error.message,\n      code: error.code,\n      statusCode: error.statusCode,\n      details: error.details,\n    };\n  }\n\n  if (error instanceof ZodError) {\n    // Format Zod errors for better readability\n    const formattedErrors = error.issues.map((err) => ({\n      field: err.path.join(\".\"),\n      message: err.message,\n      code: err.code,\n    }));\n\n    return {\n      message: `Validation error: ${formattedErrors\n        .map((e) => `${e.field}: ${e.message}`)\n        .join(\", \")}`,\n      code: \"VALIDATION_ERROR\",\n      statusCode: 400,\n      details: formattedErrors.reduce((acc, err) => {\n        acc[err.field] = err.message;\n        return acc;\n      }, {} as Record<string, string>),\n    };\n  }\n\n  if (error instanceof Error) {\n    return {\n      message: error.message,\n      statusCode: 500,\n    };\n  }\n\n  return {\n    message: \"Internal server error\",\n    statusCode: 500,\n  };\n}\n\nexport function sendErrorResponse(res: NextApiResponse, error: ApiError) {\n  const { statusCode, message, code, details = {} } = error;\n\n  res.status(statusCode).json({\n    success: false,\n    error: {\n      message,\n      code,\n      details,\n    },\n    timestamp: new Date().toISOString(),\n  });\n}\n\nexport function sendSuccessResponse<T>(\n  res: NextApiResponse,\n  data: T,\n  statusCode: number = 200\n) {\n  res.status(statusCode).json({\n    success: true,\n    data,\n    timestamp: new Date().toISOString(),\n  });\n}\n\n// Common error types\nexport const ErrorCodes = {\n  VALIDATION_ERROR: \"VALIDATION_ERROR\",\n  AUTHENTICATION_ERROR: \"AUTHENTICATION_ERROR\",\n  AUTHORIZATION_ERROR: \"AUTHORIZATION_ERROR\",\n  UNAUTHORIZED: \"UNAUTHORIZED\",\n  FORBIDDEN: \"FORBIDDEN\",\n  NOT_FOUND: \"NOT_FOUND\",\n  DUPLICATE_ENTRY: \"DUPLICATE_ENTRY\",\n  INVALID_CREDENTIALS: \"INVALID_CREDENTIALS\",\n  TOKEN_EXPIRED: \"TOKEN_EXPIRED\",\n  TOKEN_INVALID: \"TOKEN_INVALID\",\n  USER_NOT_FOUND: \"USER_NOT_FOUND\",\n  PARTNER_NOT_FOUND: \"PARTNER_NOT_FOUND\",\n  REQUEST_NOT_FOUND: \"REQUEST_NOT_FOUND\",\n  BRANCH_NOT_FOUND: \"BRANCH_NOT_FOUND\",\n  CATEGORY_NOT_FOUND: \"CATEGORY_NOT_FOUND\",\n  SERVICE_NOT_FOUND: \"SERVICE_NOT_FOUND\",\n  INVALID_STATUS_TRANSITION: \"INVALID_STATUS_TRANSITION\",\n  SLA_TIMEOUT: \"SLA_TIMEOUT\",\n  CONFIGURATION_NOT_FOUND: \"CONFIGURATION_NOT_FOUND\",\n} as const;\n","import bcrypt from \"bcryptjs\";\nimport jwt, { SignOptions } from \"jsonwebtoken\";\nimport { db } from \"../db/connection\";\nimport {\n  users,\n  userSessions,\n  customers,\n  NewUser,\n  NewCustomer,\n} from \"../db/schema\";\nimport { eq, and } from \"drizzle-orm\";\nimport { AppError, ErrorCodes } from \"../utils/errorHandler\";\nimport { logger } from \"../utils/logger\";\nimport type {\n  RegisterInput,\n  LoginInput,\n  ChangePasswordInput,\n  UpdateProfileInput,\n} from \"../../schemas/auth\";\n\nconst JWT_SECRET = process.env.JWT_SECRET as string;\nconst JWT_REFRESH_SECRET = process.env.JWT_REFRESH_SECRET as string;\nconst JWT_EXPIRES_IN = (process.env.JWT_EXPIRES_IN || \"15m\") as string;\nconst JWT_REFRESH_EXPIRES_IN = (process.env.JWT_REFRESH_EXPIRES_IN ||\n  \"7d\") as string;\n\nexport interface AuthTokens {\n  accessToken: string;\n  refreshToken: string;\n  expiresIn: number;\n}\n\nexport interface UserProfile {\n  id: number;\n  name: string;\n  email: string;\n  phone?: string;\n  userType: \"admin\" | \"partner\" | \"customer\" | \"operation\";\n  roleId: number;\n  partnerId?: number;\n  languagePreference?: string;\n  emailVerifiedAt?: Date;\n  phoneVerifiedAt?: Date;\n  lastLoginAt?: Date;\n  createdAt: Date;\n}\n\nexport class AuthService {\n  /**\n   * Register a new customer user\n   */\n  async register(\n    data: RegisterInput\n  ): Promise<{ user: UserProfile; tokens: AuthTokens }> {\n    try {\n      logger.info(\"Starting user registration\", { email: data.email });\n\n      // Check if user already exists\n      const existingUser = await db\n        .select()\n        .from(users)\n        .where(eq(users.email, data.email))\n        .limit(1);\n\n      if (existingUser.length > 0) {\n        throw new AppError(\n          \"User with this email already exists\",\n          400,\n          ErrorCodes.DUPLICATE_ENTRY\n        );\n      }\n\n      // Hash password\n      const hashedPassword = await bcrypt.hash(data.password, 12);\n\n      // Create user\n      const newUser = await db\n        .insert(users)\n        .values({\n          name: data.name,\n          email: data.email,\n          phone: data.phone,\n          password: hashedPassword,\n          roleId: 4, // customer role ID (assuming it's 4 from seed data)\n          userType: data.userType,\n          languagePreference: data.languagePreference,\n          emailVerifiedAt: new Date(), // Auto-verify for now\n        } as NewUser)\n        .returning();\n\n      // Create customer profile\n      await db.insert(customers).values({\n        userId: newUser[0].id,\n        phone: data.phone,\n        preferredLanguage: data.languagePreference,\n      });\n\n      // Generate tokens\n      const tokens = await this.generateTokens(newUser[0].id);\n\n      // Update last login\n      await db\n        .update(users)\n        .set({ lastLoginAt: new Date() } as Partial<NewUser>)\n        .where(eq(users.id, newUser[0].id));\n\n      const userProfile: UserProfile = {\n        id: newUser[0].id,\n        name: newUser[0].name,\n        email: newUser[0].email,\n        phone: newUser[0].phone || undefined,\n        userType: newUser[0].userType,\n        roleId: newUser[0].roleId,\n        partnerId: newUser[0].partnerId || undefined,\n        languagePreference: newUser[0].languagePreference || undefined,\n        emailVerifiedAt: newUser[0].emailVerifiedAt || undefined,\n        phoneVerifiedAt: newUser[0].phoneVerifiedAt || undefined,\n        lastLoginAt: newUser[0].lastLoginAt || undefined,\n        createdAt: newUser[0].createdAt!,\n      };\n\n      logger.info(\"User registered successfully\", {\n        userId: newUser[0].id,\n        email: data.email,\n      });\n\n      return { user: userProfile, tokens };\n    } catch (error) {\n      logger.error(\"Registration failed\", {\n        error: error instanceof Error ? error.message : \"Unknown error\",\n        email: data.email,\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Login user\n   */\n  async login(\n    data: LoginInput,\n    deviceInfo?: string,\n    ipAddress?: string\n  ): Promise<{ user: UserProfile; tokens: AuthTokens }> {\n    try {\n      logger.info(\"Starting user login\", { email: data.email });\n\n      // Find user\n      const user = await db\n        .select()\n        .from(users)\n        .where(\n          and(\n            eq(users.email, data.email),\n            eq(users.isActive, true),\n            eq(users.isDeleted, false)\n          )\n        )\n        .limit(1);\n\n      if (user.length === 0) {\n        throw new AppError(\n          \"Invalid credentials\",\n          401,\n          ErrorCodes.INVALID_CREDENTIALS\n        );\n      }\n\n      // Verify password\n      const isValidPassword = await bcrypt.compare(\n        data.password,\n        user[0].password\n      );\n      if (!isValidPassword) {\n        throw new AppError(\n          \"Invalid credentials\",\n          401,\n          ErrorCodes.INVALID_CREDENTIALS\n        );\n      }\n\n      // Generate tokens\n      const tokens = await this.generateTokens(\n        user[0].id,\n        deviceInfo,\n        ipAddress\n      );\n\n      // Update last login\n      await db\n        .update(users)\n        .set({ lastLoginAt: new Date() } as Partial<NewUser>)\n        .where(eq(users.id, user[0].id));\n\n      const userProfile: UserProfile = {\n        id: user[0].id,\n        name: user[0].name,\n        email: user[0].email,\n        phone: user[0].phone || undefined,\n        userType: user[0].userType,\n        roleId: user[0].roleId,\n        partnerId: user[0].partnerId || undefined,\n        languagePreference: user[0].languagePreference || undefined,\n        emailVerifiedAt: user[0].emailVerifiedAt || undefined,\n        phoneVerifiedAt: user[0].phoneVerifiedAt || undefined,\n        lastLoginAt: user[0].lastLoginAt || undefined,\n        createdAt: user[0].createdAt!,\n      };\n\n      logger.info(\"User logged in successfully\", {\n        userId: user[0].id,\n        email: data.email,\n      });\n\n      return { user: userProfile, tokens };\n    } catch (error) {\n      logger.error(\"Login failed\", {\n        error: error instanceof Error ? error.message : \"Unknown error\",\n        email: data.email,\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Refresh access token\n   */\n  async refreshToken(refreshToken: string): Promise<{ tokens: AuthTokens }> {\n    try {\n      logger.info(\"Refreshing token\");\n\n      // Verify refresh token\n      const decoded = jwt.verify(refreshToken, JWT_REFRESH_SECRET) as {\n        userId: number;\n        sessionId: string;\n      };\n\n      // Find session by sessionId\n      const session = await db\n        .select()\n        .from(userSessions)\n        .where(\n          and(\n            eq(userSessions.sessionId, decoded.sessionId),\n            eq(userSessions.isActive, true)\n          )\n        )\n        .limit(1);\n\n      if (session.length === 0) {\n        throw new AppError(\n          \"Invalid refresh token\",\n          401,\n          ErrorCodes.TOKEN_INVALID\n        );\n      }\n\n      // Check if session is expired\n      if (session[0].expiresAt < new Date()) {\n        throw new AppError(\n          \"Refresh token expired\",\n          401,\n          ErrorCodes.TOKEN_EXPIRED\n        );\n      }\n\n      // Generate new tokens with same sessionId\n      const tokens = await this.generateTokensForSession(\n        decoded.userId,\n        decoded.sessionId,\n        session[0].deviceInfo || undefined,\n        session[0].ipAddress || undefined\n      );\n\n      logger.info(\"Token refreshed successfully\", { userId: decoded.userId });\n\n      return { tokens };\n    } catch (error) {\n      logger.error(\"Token refresh failed\", {\n        error: error instanceof Error ? error.message : \"Unknown error\",\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Logout user by access token\n   */\n  async logout(token: string): Promise<void> {\n    try {\n      logger.info(\"Logging out user\");\n\n      // Decode token to get sessionId (don't verify, just decode)\n      const decoded = jwt.decode(token) as {\n        userId: number;\n        sessionId: string;\n      } | null;\n\n      if (decoded && decoded.sessionId) {\n        // Deactivate session by sessionId\n        await db\n          .update(userSessions)\n          .set({ isActive: false })\n          .where(eq(userSessions.sessionId, decoded.sessionId));\n\n        logger.info(\"User logged out successfully\", {\n          sessionId: decoded.sessionId,\n        });\n      }\n    } catch (error) {\n      logger.error(\"Logout failed\", {\n        error: error instanceof Error ? error.message : \"Unknown error\",\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Get user profile\n   */\n  async getUserProfile(userId: number): Promise<UserProfile> {\n    try {\n      const user = await db\n        .select()\n        .from(users)\n        .where(\n          and(\n            eq(users.id, userId),\n            eq(users.isActive, true),\n            eq(users.isDeleted, false)\n          )\n        )\n        .limit(1);\n\n      if (user.length === 0) {\n        throw new AppError(\"User not found\", 404, ErrorCodes.USER_NOT_FOUND);\n      }\n\n      const userProfile: UserProfile = {\n        id: user[0].id,\n        name: user[0].name,\n        email: user[0].email,\n        phone: user[0].phone || undefined,\n        userType: user[0].userType,\n        roleId: user[0].roleId,\n        partnerId: user[0].partnerId || undefined,\n        languagePreference: user[0].languagePreference || undefined,\n        emailVerifiedAt: user[0].emailVerifiedAt || undefined,\n        phoneVerifiedAt: user[0].phoneVerifiedAt || undefined,\n        lastLoginAt: user[0].lastLoginAt || undefined,\n        createdAt: user[0].createdAt!,\n      };\n\n      return userProfile;\n    } catch (error) {\n      logger.error(\"Get user profile failed\", {\n        error: error instanceof Error ? error.message : \"Unknown error\",\n        userId,\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Change user password\n   */\n  async changePassword(\n    userId: number,\n    data: ChangePasswordInput\n  ): Promise<void> {\n    try {\n      logger.info(\"Changing user password\", { userId });\n\n      // Get user\n      const user = await db\n        .select()\n        .from(users)\n        .where(\n          and(\n            eq(users.id, userId),\n            eq(users.isActive, true),\n            eq(users.isDeleted, false)\n          )\n        )\n        .limit(1);\n\n      if (user.length === 0) {\n        throw new AppError(\"User not found\", 404, ErrorCodes.USER_NOT_FOUND);\n      }\n\n      // Verify current password\n      const isValidPassword = await bcrypt.compare(\n        data.currentPassword,\n        user[0].password\n      );\n      if (!isValidPassword) {\n        throw new AppError(\n          \"Current password is incorrect\",\n          400,\n          ErrorCodes.INVALID_CREDENTIALS\n        );\n      }\n\n      // Hash new password\n      const hashedPassword = await bcrypt.hash(data.newPassword, 12);\n\n      // Update password\n      await db\n        .update(users)\n        .set({\n          password: hashedPassword,\n          updatedAt: new Date(),\n        } as Partial<NewUser>)\n        .where(eq(users.id, userId));\n\n      logger.info(\"Password changed successfully\", { userId });\n    } catch (error) {\n      logger.error(\"Change password failed\", {\n        error: error instanceof Error ? error.message : \"Unknown error\",\n        userId,\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Update user profile\n   */\n  async updateProfile(\n    userId: number,\n    data: UpdateProfileInput\n  ): Promise<UserProfile> {\n    try {\n      logger.info(\"Updating user profile\", { userId });\n\n      // Update user\n      const updatedUser = await db\n        .update(users)\n        .set({\n          ...data,\n          updatedAt: new Date(),\n        } as Partial<NewUser>)\n        .where(\n          and(\n            eq(users.id, userId),\n            eq(users.isActive, true),\n            eq(users.isDeleted, false)\n          )\n        )\n        .returning();\n\n      if (updatedUser.length === 0) {\n        throw new AppError(\"User not found\", 404, ErrorCodes.USER_NOT_FOUND);\n      }\n\n      // Update customer profile if applicable\n      if (data.phone && updatedUser[0].userType === \"customer\") {\n        await db\n          .update(customers)\n          .set({\n            phone: data.phone,\n            preferredLanguage:\n              data.languagePreference || updatedUser[0].languagePreference,\n            updatedAt: new Date(),\n          } as Partial<NewCustomer>)\n          .where(eq(customers.userId, userId));\n      }\n\n      const userProfile: UserProfile = {\n        id: updatedUser[0].id,\n        name: updatedUser[0].name,\n        email: updatedUser[0].email,\n        phone: updatedUser[0].phone || undefined,\n        userType: updatedUser[0].userType,\n        roleId: updatedUser[0].roleId,\n        partnerId: updatedUser[0].partnerId || undefined,\n        languagePreference: updatedUser[0].languagePreference || undefined,\n        emailVerifiedAt: updatedUser[0].emailVerifiedAt || undefined,\n        phoneVerifiedAt: updatedUser[0].phoneVerifiedAt || undefined,\n        lastLoginAt: updatedUser[0].lastLoginAt || undefined,\n        createdAt: updatedUser[0].createdAt!,\n      };\n\n      logger.info(\"Profile updated successfully\", { userId });\n\n      return userProfile;\n    } catch (error) {\n      logger.error(\"Update profile failed\", {\n        error: error instanceof Error ? error.message : \"Unknown error\",\n        userId,\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Generate JWT tokens\n   */\n  async generateTokens(\n    userId: number,\n    deviceInfo?: string,\n    ipAddress?: string\n  ): Promise<AuthTokens> {\n    const sessionId = `session_${Date.now()}_${Math.random()\n      .toString(36)\n      .substr(2, 9)}`;\n\n    return this.generateTokensForSession(\n      userId,\n      sessionId,\n      deviceInfo,\n      ipAddress\n    );\n  }\n\n  /**\n   * Generate JWT tokens for a specific session\n   */\n  private async generateTokensForSession(\n    userId: number,\n    sessionId: string,\n    deviceInfo?: string,\n    ipAddress?: string\n  ): Promise<AuthTokens> {\n    // Create access token\n    const accessToken = jwt.sign(\n      { userId, sessionId } as Record<string, unknown>,\n      JWT_SECRET,\n      {\n        expiresIn: JWT_EXPIRES_IN,\n      } as SignOptions\n    );\n\n    // Create refresh token\n    const refreshToken = jwt.sign(\n      { userId, sessionId } as Record<string, unknown>,\n      JWT_REFRESH_SECRET,\n      {\n        expiresIn: JWT_REFRESH_EXPIRES_IN,\n      } as SignOptions\n    );\n\n    // Calculate expiration time\n    const expiresIn = this.getTokenExpirationTime(JWT_EXPIRES_IN);\n\n    try {\n      // Check if session already exists (for refresh token flow)\n      const existingSession = await db\n        .select()\n        .from(userSessions)\n        .where(eq(userSessions.sessionId, sessionId))\n        .limit(1);\n\n      if (existingSession.length === 0) {\n        // Create new session\n        await db.insert(userSessions).values({\n          userId,\n          sessionId,\n          expiresAt: new Date(\n            Date.now() +\n              this.getTokenExpirationTime(JWT_REFRESH_EXPIRES_IN) * 1000\n          ),\n          deviceInfo,\n          ipAddress,\n        });\n\n        logger.info(\"Session created successfully\", { userId, sessionId });\n      } else {\n        // Update existing session expiration\n        await db\n          .update(userSessions)\n          .set({\n            expiresAt: new Date(\n              Date.now() +\n                this.getTokenExpirationTime(JWT_REFRESH_EXPIRES_IN) * 1000\n            ),\n            isActive: true, // Reactivate if needed\n          })\n          .where(eq(userSessions.sessionId, sessionId));\n\n        logger.info(\"Session refreshed successfully\", { userId, sessionId });\n      }\n    } catch (error) {\n      logger.error(\"Failed to create/update session\", {\n        error: error instanceof Error ? error.message : \"Unknown error\",\n        userId,\n      });\n      throw new AppError(\"Failed to create session\", 500, \"DATABASE_ERROR\");\n    }\n\n    return {\n      accessToken,\n      refreshToken,\n      expiresIn,\n    };\n  }\n\n  /**\n   * Get token expiration time in seconds\n   */\n  private getTokenExpirationTime(expiresIn: string): number {\n    const unit = expiresIn.slice(-1);\n    const value = parseInt(expiresIn.slice(0, -1));\n\n    switch (unit) {\n      case \"s\":\n        return value;\n      case \"m\":\n        return value * 60;\n      case \"h\":\n        return value * 60 * 60;\n      case \"d\":\n        return value * 24 * 60 * 60;\n      default:\n        return 15 * 60; // 15 minutes default\n    }\n  }\n\n  /**\n   * Verify access token\n   */\n  async verifyToken(\n    token: string\n  ): Promise<{ userId: number; sessionId: string }> {\n    try {\n      // Verify JWT signature and expiration\n      const decoded = jwt.verify(token, JWT_SECRET) as {\n        userId: number;\n        sessionId: string;\n      };\n\n      // Check if session exists and is active\n      const session = await db\n        .select()\n        .from(userSessions)\n        .where(\n          and(\n            eq(userSessions.sessionId, decoded.sessionId),\n            eq(userSessions.isActive, true)\n          )\n        )\n        .limit(1);\n\n      if (session.length === 0) {\n        throw new AppError(\n          \"Session expired or invalid\",\n          401,\n          ErrorCodes.TOKEN_INVALID\n        );\n      }\n\n      // Check if session has expired\n      if (session[0].expiresAt && session[0].expiresAt < new Date()) {\n        // Deactivate expired session\n        await db\n          .update(userSessions)\n          .set({ isActive: false })\n          .where(eq(userSessions.id, session[0].id));\n\n        throw new AppError(\"Session expired\", 401, ErrorCodes.TOKEN_EXPIRED);\n      }\n\n      return decoded;\n    } catch (error) {\n      if (error instanceof jwt.JsonWebTokenError) {\n        throw new AppError(\"Invalid token\", 401, ErrorCodes.TOKEN_INVALID);\n      }\n      if (error instanceof jwt.TokenExpiredError) {\n        throw new AppError(\"Token expired\", 401, ErrorCodes.TOKEN_EXPIRED);\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Generate password reset token\n   */\n  async generatePasswordResetToken(email: string): Promise<string> {\n    try {\n      logger.info(\"Generating password reset token\", { email });\n\n      // Find user by email\n      const user = await db\n        .select()\n        .from(users)\n        .where(\n          and(\n            eq(users.email, email),\n            eq(users.isActive, true),\n            eq(users.isDeleted, false)\n          )\n        )\n        .limit(1);\n\n      // Generate reset token (valid for 1 hour) - only if user exists\n      let resetToken = \"\";\n\n      if (user.length > 0) {\n        resetToken = jwt.sign(\n          {\n            userId: user[0].id,\n            email: user[0].email,\n            type: \"password_reset\",\n          },\n          JWT_SECRET,\n          { expiresIn: \"1h\" }\n        );\n        logger.info(\"Password reset token generated\", {\n          email,\n          userId: user[0].id,\n        });\n      } else {\n        // For security, don't reveal if user doesn't exist\n        logger.info(\"Password reset requested for non-existent email\", {\n          email,\n        });\n      }\n\n      return resetToken;\n    } catch (error) {\n      logger.error(\"Generate password reset token failed\", {\n        error: error instanceof Error ? error.message : \"Unknown error\",\n        email,\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Verify password reset token\n   */\n  async verifyPasswordResetToken(\n    token: string\n  ): Promise<{ userId: number; email: string }> {\n    try {\n      const decoded = jwt.verify(token, JWT_SECRET) as {\n        userId: number;\n        email: string;\n        type: string;\n      };\n\n      if (decoded.type !== \"password_reset\") {\n        throw new AppError(\n          \"Invalid reset token\",\n          400,\n          ErrorCodes.TOKEN_INVALID\n        );\n      }\n\n      // Verify user still exists and is active\n      const user = await db\n        .select()\n        .from(users)\n        .where(\n          and(\n            eq(users.id, decoded.userId),\n            eq(users.isActive, true),\n            eq(users.isDeleted, false)\n          )\n        )\n        .limit(1);\n\n      if (user.length === 0) {\n        throw new AppError(\n          \"User not found or inactive\",\n          404,\n          ErrorCodes.USER_NOT_FOUND\n        );\n      }\n\n      return { userId: decoded.userId, email: decoded.email };\n    } catch (error) {\n      if (error instanceof jwt.TokenExpiredError) {\n        throw new AppError(\n          \"Reset token has expired\",\n          400,\n          ErrorCodes.TOKEN_EXPIRED\n        );\n      }\n      if (error instanceof jwt.JsonWebTokenError) {\n        throw new AppError(\n          \"Invalid reset token\",\n          400,\n          ErrorCodes.TOKEN_INVALID\n        );\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Reset password using token\n   */\n  async resetPassword(token: string, newPassword: string): Promise<void> {\n    try {\n      logger.info(\"Resetting password\");\n\n      // Verify token and get user info\n      const { userId } = await this.verifyPasswordResetToken(token);\n\n      // Hash new password\n      const hashedPassword = await bcrypt.hash(newPassword, 12);\n\n      // Update password\n      await db\n        .update(users)\n        .set({\n          password: hashedPassword,\n          updatedAt: new Date(),\n        } as Partial<NewUser>)\n        .where(eq(users.id, userId));\n\n      // Invalidate all existing sessions for security\n      await db\n        .update(userSessions)\n        .set({\n          isActive: false,\n        })\n        .where(eq(userSessions.userId, userId));\n\n      logger.info(\"Password reset successfully\", { userId });\n    } catch (error) {\n      logger.error(\"Reset password failed\", {\n        error: error instanceof Error ? error.message : \"Unknown error\",\n      });\n      throw error;\n    }\n  }\n}\n\nexport const authService = new AuthService();\n"],"names":[],"mappings":"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"}